#+TITLE: Emacs Configuration
#+AUTHOR: Dmitri Akatov
#+Email: akatov@gmail.com

* Startup
** Header

This is to remind me in case I start editing [[file:README.el][readme.el]] by mistake...

#+BEGIN_SRC emacs-lisp
;; readme.el is autogenerated by org-babel-load-file from readme.org ;;
;; -------------- do not edit this file directly ------------------- ;;
#+END_SRC

** Package
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
	     '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives
	     '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives
	     '("SC" . "http://joseito.republika.pl/sunrise-commander/") t)
(package-initialize)
#+END_SRC

** Use-Package

use use-package to configure (and install) everything else

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
(eval-when-compile
  (require 'use-package))
(require 'diminish)
(require 'bind-key)
#+END_SRC

* Global Config

** Frame

#+BEGIN_SRC emacs-lisp
(when window-system
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1))
#+END_SRC

** Path

In NextStep (OSX) window mode load the path settings from the shell

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
	     :if (memq window-system '(mac ns))
	     :ensure t
	     :init
	     (setq exec-path-from-shell-variables
		   '("PATH"
		     "MANPATH"
		     "GOPATH"
		     "MAVEN_OPTS"))
	     (exec-path-from-shell-initialize))
#+END_SRC

** Defaults

Just answer `y` or `n`.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Custom-File

Keep custom settings in a [[file:custom.el][separate custom file.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

I try to keep the custom file empty, and instead put all the customizations in
this file. Hence the custom file is gitignored.

** Backup Files

Place backup files in emacs's temp directory

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      '(("." . "~/.emacs.d/temp")))
#+END_SRC

** Lock Files

Lock files will interefere with some auto-build tools

#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC

** General Customizations

These are the customizations that may have lived in the custom file,
and don't have anything to do with any specific mode refered to
from use-package...

#+BEGIN_SRC emacs-lisp
(ido-mode 'buffers)    ;; I only like ido-mode for switching buffers.
(blink-cursor-mode t)  ;; turn blinking on
(column-number-mode t) ;; show columns
(setq mouse-wheel-progressive-speed nil)
(setq mouse-wheel-scroll-amount
      '((nil . 1)
	((control) . 3)
	((shift) . 5)
	((control shift) . 7)
	((meta) . 9)
	((meta control) . 11)
	((meta shift) . 13)
	((meta shift control) . 1.0)))
#+END_SRC

** Keybindings

Some global keybindings I like to use...

#+BEGIN_SRC emacs-lisp
(bind-keys ("M-g h" . windmove-left)
           ("M-g j" . windmove-down)
           ("M-g k" . windmove-up)
           ("M-g l" . windmove-right)
           ("M-g M-h" . windmove-left)
           ("M-g M-j" . windmove-down)
           ("M-g M-k" . windmove-up)
           ("M-g M-l" . windmove-right))
(bind-key "<s-return>" 'toggle-frame-fullscreen)
#+END_SRC

** Hooks

#+BEGIN_SRC emacs-lisp
(defun add-hooks (mode-hooks hooks)
  (loop for mode-hook in mode-hooks do
        (loop for hook in hooks do
              (add-hook mode-hook hook))))
#+END_SRC
* Private Config

Some configuration settings I don't want the world to see.
I keep them in a separate private repo.

#+BEGIN_SRC emacs-lisp
(use-package f
  :ensure t)
(if (file-exists-p "~/.emacs.d/private")
  (mapc (lambda (f) (load f)) (f-files "~/.emacs.d/private")))
#+END_SRC

* Theme

** Cyberpunk theme

#+BEGIN_SRC emacs-lisp
(use-package cyberpunk-theme
	     :if (window-system)
	     :ensure t
	     :init
	     (progn
	       (load-theme 'cyberpunk t)
	       (set-face-attribute `mode-line nil
				   :box nil)
	       (set-face-attribute `mode-line-inactive nil
				   :box nil)))
#+END_SRC

** Solarized theme

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
	     :defer 10
	     :init
	     (setq solarized-use-variable-pitch nil)
	     :ensure t)
#+END_SRC

** Monokai theme

#+BEGIN_SRC emacs-lisp :tangle no
(use-package monokai-theme
	     :if (window-system)
	     :ensure t
	     :init
	     (setq monokai-use-variable-pitch nil))
#+end_src

** Waher theme

#+BEGIN_SRC emacs-lisp :tangle no
(use-package waher-theme
	     :if (window-system)
	     :ensure t
	     :init
	     (load-theme 'waher))
#+end_src

** Convenient theme functions

#+begin_src emacs-lisp
(defun switch-theme (theme)
  "Disables any currently active themes and loads THEME."
  ;; This interactive call is taken from `load-theme'
  (interactive
   (list
    (intern (completing-read "Load custom theme: "
                             (mapc 'symbol-name
                                   (custom-available-themes))))))
  (let ((enabled-themes custom-enabled-themes))
    (mapc #'disable-theme custom-enabled-themes)
    (load-theme theme t)))

(defun disable-active-themes ()
  "Disables any currently active themes listed in `custom-enabled-themes'."
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(bind-key "s-<f12>" 'switch-theme)
(bind-key "s-<f11>" 'disable-active-themes)
#+end_src

* Org Mode

#+BEGIN_SRC emacs-lisp
(use-package org
             :ensure t)
(define-key global-map "\C-cl" 'org-store-link)
(define-key global-map "\C-ca" 'org-agenda)
(setq org-log-done t)
(setq org-use-speed-commands t)
(setq org-return-follows-link nil)
(setq org-src-preserve-indentation t)
#+END_SRC

** babel

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (clojure . t)))

;; Use cider as the clojure execution backend
(setq org-babel-clojure-backend 'cider)

;; Let's have pretty source code blocks
(setq org-edit-src-content-indentation 0
      org-src-tab-acts-natively t
      org-src-fontify-natively t
      org-confirm-babel-evaluate nil)
#+END_SRC

** plus contrib

#+BEGIN_SRC emacs-lisp
(use-package org-plus-contrib)
#+END_SRC

** Ox Reveal

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal)
#+END_SRC

* Package Config

** Ace-Jump

#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
	     :ensure t
	     :bind (("C-;" . ace-jump-mode)
		    ("C-c SPC" . ace-jump-mode)
		    ("C-c C-SPC" . ace-jump-mode)))
#+END_SRC

** Subword

#+BEGIN_SRC emacs-lisp
(use-package subword-mode
	     :init
	     (add-hooks
	      '(haskell-mode-hook
		coffee-mode-hook
		js2-mode-hook)
	      '(subword-mode)))
#+END_SRC

** Paredit

#+BEGIN_SRC emacs-lisp
(use-package paredit
	     :ensure t
	     :init

	     (autoload 'enable-paredit-mode "paredit"
	       "Turn on pseudo-structural editing of Lisp code."
	       t)

	     (defvar electrify-return-match
	       "[\]}\)\"]"
	       "If this regexp matches the text after the cursor, do an \"electric\"
    return.")

	     (defun electrify-return-if-match (arg)
	       "If the text after the cursor matches `electrify-return-match' then
    open and indent an empty line between the cursor and the text.  Move the
    cursor to the new line."
	       (interactive "P")
	       (let ((case-fold-search nil))
		 (if (looking-at electrify-return-match)
		     (save-excursion (newline-and-indent)))
		 (newline arg)
		 (indent-according-to-mode)))

	     (defun activate-electrify-return ()
	       (local-set-key (kbd "RET") 'electrify-return-if-match))

	     (defun activate-clojure-paredit-curly ()
	       (define-key clojure-mode-map "{" 'paredit-open-curly)
	       (define-key clojure-mode-map "}" 'paredit-close-curly))

	     (defun setup-paredit-eldoc-commands ()
	       (turn-on-eldoc-mode)
	       (eldoc-add-command 'paredit-backward-delete
				  'paredit-close-round
				  'electrify-return-if-match))

	     (add-hook 'clojure-mode-hook 'activate-clojure-paredit-curly)

	     (add-hooks '(emacs-lisp-mode-hook)
			'(activate-electrify-return
			  setup-paredit-eldoc-commands))

  ;;; paredit doesn't do this automatically
	     (add-hooks
	      '(clojure-mode-hook
		emacs-lisp-mode-hook
		lisp-interaction-mode-hook
		lisp-mode-hook
		scheme-mode-hook)
	      '(enable-paredit-mode))

  ;;; paredit for javascript

	     (defun my-paredit-nonlisp ()
	       "Turn on paredit mode for non-lisps."
	       (interactive)
	       (set (make-local-variable 'paredit-space-for-delimiter-predicates)
		    '((lambda (endp delimiter) nil)))
	       (paredit-mode 1))

	     (defun activate-js2-paredit-curly ()
	       (define-key js2-mode-map "{" 'paredit-open-curly)
	       (define-key js2-mode-map "}" 'paredit-close-curly))

	     (add-hook 'js2-mode-hook 'activate-js2-paredit-curly)

	     (add-hooks
	      '(js-mode-hook js2-mode-hook)
	      '(my-paredit-nonlisp)))
#+END_SRC

** Handlebars Sgml Mode

#+BEGIN_SRC emacs-lisp
(use-package handlebars-sgml-mode
	     :ensure t)
#+END_SRC

** Less Css Mode

#+BEGIN_SRC emacs-lisp
(use-package less-css-mode
	     :ensure t)
#+END_SRC

** JSCS

#+BEGIN_SRC emacs-lisp
;; (use-package jscs
;;   :init
;;   (add-hook 'js-mode-hook #'jscs-indent-apply)
;;   (add-hook 'js2-mode-hook #'jscs-indent-apply)
;;   (add-hook 'json-mode-hook #'jscs-indent-apply))
#+END_SRC

** js2-mode

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
	     :init
	     (setq inferior-js-program-command "node")
	     (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
	     (add-to-list 'auto-mode-alist '("\\.json\\'" . js2-mode)))
#+END_SRC

** markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
	     :init
	     (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode)))
#+END_SRC

** company

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  ;; :init
  ;; (global-company-mode)
  )
#+END_SRC

** company-quickhelp

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  ;; :init
  ;; (company-quickhelp-mode 1)
  )
#+END_SRC

** js2-highlight-vars

#+BEGIN_SRC emacs-lisp
  ;; (use-package js2-highlight-vars
  ;;   :init
  ;;   (add-hook 'js2-mode-hook 'js2-highlight-vars-mode))
#+END_SRC

** yaml-mode

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
	     :ensure t)
#+END_SRC

** neotree

#+BEGIN_SRC emacs-lisp
(use-package neotree
	     :ensure t
	     :init
	     (bind-key [f8] 'neotree-toggle))
#+END_SRC

** cider

#+BEGIN_SRC emacs-lisp
(use-package cider
	     :ensure t
	     :init
	     (setq nrepl-hide-special-buffers t
		   cider-repl-pop-to-buffer-on-connect nil
		   cider-popup-stacktraces nil
		   cider-repl-popup-stacktraces t))
#+END_SRC

** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
	     :ensure t
	     :init
	     (bind-key "C-x g" 'magit-status))
#+END_SRC

** discover modes

#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
	     :init
	     (global-set-key (kbd "C-h M-m") 'discover-my-major)
	     (global-set-key (kbd "C-h M-M") 'discover-my-mode))
#+END_SRC

* XMPP

#+BEGIN_SRC emacs-lisp
(use-package jabber
	     :ensure t)
#+END_SRC

* Temp

These definitions are looking to be moved somewhere else.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
	     :config (set-face-background 'hl-line "#073642"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-emoji
	     :init
	     (defun --set-emoji-font (frame)
	       "Adjust the font settings of FRAME so Emacs can display emoji properly."
	       (if (eq system-type 'darwin)
		   ;; For NS/Cocoa
		   (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
		 ;; For Linux
		 (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

	     ;; For when Emacs is started in GUI mode:
	     (--set-emoji-font nil)
	     ;; Hook for when a frame is created with emacsclient
	     ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
	     :config
	     (add-to-list 'company-backends 'company-emoji)
	     (add-hook 'after-make-frame-functions '--set-emoji-font)
	     (setq company-emoji-insert-unicode nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package origami
	     :ensure t
	     ;; TODO: keybindings
	     )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package tagedit
	     :ensure t
	     :init
	     (tagedit-add-paredit-like-keybindings)
	     (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))
	     (add-hook 'handlebars-mode-hook (lambda () (tagedit-mode 1))))
#+END_SRC
